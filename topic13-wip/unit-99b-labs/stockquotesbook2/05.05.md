# Computing Statistics - StatReport.hs



This module uses lists of QuoteData instances and returns calcluations based on this data.

Firstly look at the **avgOpen** function:
 ```
avgOpen :: [QuoteData] -> Double  -- average  opening values
avgOpen all =  sum (map open all)  / fromIntegral (length all)
```
This takes all the opening values, sums them and divides by the number of opening values (size of list) to return the average of all the opening values.

Note: 
   using 
``` 
map open all 
```
 - remember applying open takes a QuoteData instance and returns the 'open' field value of that instance. By mapping this across the list of QuoteData instances, we return the list of open values. 
 - We use **fromIntegral** to allow us real division 
  
---


This is an updated version of the previous version. This is a more usable version in that

- we structure the output in a more structured way so that we can use this output for use e.g. with html generation

- we introduce the type class  **Foldable** (see more [here](http://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Foldable.html)). which allows us (in a slightly unhaskelly loopy way!) to compute the stats for all the fields (open, close etc)

- we introduce the type class  **Buildable**   (see more [here](https://hackage.haskell.org/package/buildable-0.1.0.3/docs/Data-Buildable.html))  which allows us to build up a list (we define one element of the list and then build up a list made up of these elements)

- we introduce the **fmt** package to format values.

- we use the **Colonnade** package which  allows defining a *structure* of the table that is a collection of columns. Every column is defined by the column header and a function to *extract* and *format* a value from the data structure corresponding to one row of the table. Tables in `colonnade` are `Monoid` values. Every column is a one-columned table. If we combine two columns with `(<>)` we get a two-columned table. Once a table structure is ready, we supply a list of row values. The library then prepares data, computes column widths and format output in a tabular form. All this functionality is provided by the `Colonnade` module.

  To organize tabular printing as a text for `[StatEntry]` we define a list of columns, `mconcat` them, and then call an *ascii* function which produces a `String` formatted as a table.



Have a look at the overall code. I have commented the new parts in most cases. Ensure that you understood the previous version first. 





```haskell
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE OverloadedStrings #-}

module StatReport where

import Data.Ord (comparing)
import Data.Foldable (minimumBy, maximumBy)
import Data.Time (diffDays)
import Fmt      -- used for formating text
    ( Buildable(..),
      Builder,
      (+|),
      (+||),
      pretty,
      (|+),
      (||+),
      fixedF )          
import Colonnade ( ascii, headed )

import QuoteData ( field2fun, QField(Volume), QuoteData(day) )

decimalPlacesFloating :: Int
decimalPlacesFloating = 2

data StatValue = StatValue {     --this is used to format the calculated fields
    decimalPlaces :: Int,
    value :: Double
  }

data StatEntry = StatEntry {     -- where we store our stat results
    qfield :: QField,
    meanVal :: StatValue,
    minVal :: StatValue,
    maxVal :: StatValue,
    daysBetweenMinMax :: Int
  }

mean :: (Fractional a, Foldable t) => t a -> a   --this allow us to calculate our mean for any foldable type
mean xs = sum xs / fromIntegral (length xs)

computeMinMaxDays :: (Ord a, Foldable t) =>      --this has an extra parameter 'get' whuch allows us to indicate which field of QuoteData to compute on
                                                  -- we use this in statInfo to compute for all the fields of QuoteData
                     (QuoteData -> a) -> t QuoteData -> (a, a, Int)
computeMinMaxDays get quotes = (get minQ, get maxQ, days)
  where
    cmp = comparing get
    minQ = minimumBy cmp quotes
    maxQ = maximumBy cmp quotes
    days = fromIntegral $ abs $ diffDays (day minQ) (day maxQ)

statInfo :: (Functor t, Foldable t) => t QuoteData -> [StatEntry]
statInfo quotes = fmap qFieldStatInfo [minBound .. maxBound]        -- this says 'use all of the qField values from start to finish in that order (Open .. Volume)
                                                                    -- from 'data QField = Open | Close | High | Low | Volume' in QuoteData
  where  
    decimalPlacesByQField Volume = 0                                -- this is for the integral field - no fractional part
    decimalPlacesByQField _ = decimalPlacesFloating                 -- the other fields get 2 decimal places 

    qFieldStatInfo qfield =
      let
        get = field2fun qfield                                       --this brings in the field (open, close that we are working on)
        (mn, mx, daysBetweenMinMax) =
              computeMinMaxDays get quotes                          -- get would be e.g. open
        decPlaces = decimalPlacesByQField qfield
        meanVal = StatValue decimalPlacesFloating
                            (mean $ fmap get quotes)                -- extract a Foldable with one field
        minVal = StatValue decPlaces mn
        maxVal = StatValue decPlaces mx
      in StatEntry {..}                                               -- build up  a list of StatEntry as the result, usinga RecordWildCards to fill the record



instance Buildable StatValue where                                    -- we use instance to define the use of StatValue in statInfo
  build sv = fixedF (decimalPlaces sv) (value sv)                     -- format doubles - 'fixedF' of from fmt package

instance Buildable StatEntry where                                    -- we use instance to define how StatEntry will look. This structure will be used for text and html..   
  build StatEntry {..} =
           ""+||qfield||+": "                                         -- this code requires RecordWildCards and OverloadedStrings
             +|meanVal|+" (mean), "
             +|minVal|+" (min), "
             +|maxVal|+" (max), "
             +|daysBetweenMinMax|+" (days)"

textReport :: [StatEntry] -> String                                    -- we get a built StatEntry and format it into a String for text purposes
textReport = ascii colStats                                            -- ascii is from Colonnade 
  where
    colStats = mconcat
      [ headed "Quote Field" (show . qfield)                           -- headed is from Colonnade
      , headed "Mean" (pretty . meanVal)                               -- pretty is for formatting
      , headed "Min" (pretty . minVal)
      , headed "Max" (pretty . maxVal)
      , headed "Days between Min/Max" (pretty . daysBetweenMinMax)
      ]

showPrice :: Double -> Builder                                            -- we will use this for html formatting (auxiliary function)
showPrice = fixedF decimalPlacesFloating

```
