# Describing the data - QuoteData.hs

Because we are using library functions, we do not control what types are returned by and expected by  the various functions. So,  to  make us ready for these functions, sometimes, we need to bring in other types that do not appear in our interface. This is quite common in Haskell. For this section, we use ByteString which is a type use to store e.g. Strings efficiently. 

We wish to examine what is in each record of the quotes.csv file. We will use the cassava package to read from the file directly into this structure:

 ![fields od quotes.csv)](./img/10.png)

We define a new data type that encompasses this strusture:
```
data QuoteData = QuoteData {  
                   day :: Day,
                   volume :: Int,
                   open :: Double,
                   close :: Double,
                   high :: Double,
                   low :: Double
                 }
  deriving (Ord, Eq, Show)
  ```
  Note that these fields are not in the same order that the fields in the csv file - we have re-ordered them for clarity.
  
  We use the 'Day' type which is new to us. This is part of the Data.Time (so you need to import the library and include it in the dependencies file (package.yaml)).

#### Cooking data for `cassava`

**cassava** [(more here)](https://hackage.haskell.org/package/cassava) is a package that parses data coming from csv files.  When we obey its rules (interfaces) it very elegantly reads in an entire csv file into a structure of your making (if, of course the csv file matches the structure you wish to import it into.)

To describe our data in a form suitable for the `cassava` package, we’ll derive or define instances of several type classes, namely:

- `Generic` from the `GHC.Generics` module to give `cassava` instances for working with our data types using generic programming machinery
- `FromNamedRecord` from the `Data.Csv` module to allow `cassava` to read a CSV file with named fields: this will be possible thanks to the same names being used in the CSV file and the `QuoteData` data type;
- `FromField` from the `Data.Csv` module to teach `cassava` how to parse `Day` values; `cassava` can parse values of many types by default, but it doesn’t know how to deal with Day, among other types.

Note the heavy use of type classes. This is quite common  in Haskell. The library cannot imagine all types it is used with (those types may not even exist yet). Instead, it describes constraints and behavior with type classes. Now it’s our responsibility to provide the corresponding instances in order to use the library. Thus type class instances build a bridge between the library’s interface (API in the form of type classes and functions that rely on them) and our data types.

The code we are going to write requires a couple of GHC extensions for instance derivation:

```haskell
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveAnyClass #-}
```

(GHC extensions are quite common and they extend the behavior of the `deriving` clause in datatype declarations.)



We’ll aso need to import several modules, some like before

```haskell
import Data.Time (Day, parseTimeM, defaultTimeLocale)
import Data.ByteString.Char8 (unpack)
import GHC.Generics (Generic)
import Data.Csv (FromNamedRecord, FromField (..))
```

The `cassava` package knows nothing about the `Day` type, so we need to teach this library how to parse it. This can be done by implementing an instance of the `FromField` type class which is defined in `Data.Csv` as follows:  (we do not need to write this code as this is what we get by importing FromField)

```haskell
class FromField a where
  parseField :: Field -> Parser a
  {-# MINIMAL parseField #-}
```



This type class defines how to parse a field of type `a`. The type `Field` is a synonym for `ByteString` (that’s why we’ve imported `unpack`) and `Parser` is a monadic parser used inside `cassava`. We we will see later about monads, but for the moment, so we don’t even need to think about what this `Parser` is about—it’s a monad, that’s enough. This is one possible instance for `Day`:

```haskell
instance FromField Day where
  parseField = parseTimeM True defaultTimeLocale "%Y-%m-%d" . unpack
```



We first unpack the given `ByteString` into a `String` (this is what `unpack` does) and then use the `parseTimeM` function. This function can work in any monad to parse a `Day` value; it will report a failure to the underlying monad in case of errors. So we can safely use the parser even if we are not sure of the parseability of our file. 

In addition to a `String` with a value, the `parseTimeM` function takes an expected date or time format, a date/time locale, and a flag for whether to accept leading and trailing spaces in the given `String`.

Once we have the `FromField` instance for the `Day` type, we can derive a corresponding instance for the `QuoteData` itself as follows:



```haskell
data QuoteData = QuoteData {
                   ...
                 }
  deriving (Generic, FromNamedRecord)
```



This is enough for `cassava` to decode a CSV file and create a `QuoteData` value from every line if the given file is parsed correctly.



#### Cooking data for computing statistics

We will see that there is not much difference in computing minimums or maximums for opening or closing share prices. If we have an array-like structure for those values, we could process them uniformly. Of course, we have `Int` values for volumes as well, not only `Double`, and we still need to compute minimums and maximums for the `volume` field. We cannot put `Int` and `Double` into one list or any other array-like data structure. 

Our  solution is as follows:

- We introduce a data type for referring to those fields of the `QuoteData` data type, which require statistical processing.
- We write a function which transforms both `Int` and `Double` `QuoteData` components into `Double` based on the required field information.

This is the first part of this plan:

```haskell
data QField = Open | Close | High | Low | Volume
  deriving (Eq, Ord, Show, Enum, Bounded)

field2fun :: QField -> QuoteData -> Double
field2fun Open = open
field2fun Close = close
field2fun High = high
field2fun Low = low
field2fun Volume = fromIntegral . volume
```

We’ve defined a value constructor for every numeric field in `QuoteData` and mapped it to the record fields  As a result, we’ll be able to write something like `field2fun qf q` to access any required field `qf` from a value `q` of the `QuoteData` type.

Note that we never defined the `QuoteDataCollection` data type for storing a collection of the `QuoteData` values. In fact, we don’t need it. Any such collection can well be `Foldable t => t QuoteData`. An interface we have from the `Foldable` type class is enough to do whatever we want with the data. 

All further functions we are going to implement will work with the resulting data, because the list type implements the `Foldable` type class.
