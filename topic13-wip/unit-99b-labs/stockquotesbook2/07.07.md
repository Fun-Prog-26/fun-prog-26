# Bringing it together (Main.hs)
Now, we 'bring it all together'. This is the part of the program that interacts to the outside world. 

This is indicated by main's return type. 

```haskell
main :: IO ()
```
To connect all the parts of the project together, we should:

- get the name of the csv file (from keyboard)
- get the name of the html file we wish to create
- read the CSV file
- compute the statistics
- prepare and print a text report 
- prepare and export the HTML report

We will split this job into three functions :

- `main`

- `generateReports`

The `main` function is responsible for reading in csv and html filename, then calling the csv parser to return the list of QuoteData and passing this to the `generateReports` function. 

```haskell
main ::  IO ()
main  = do
  putStrLn "Please enter the filepath/name of the csv file:"
  fname <- getLine 
  putStrLn "Please enter the name of the html target file"
  htmlFile <- getLine
  csvData <- BL.readFile fname
  case decodeByName csvData of
    Left err -> putStrLn err
    Right (_, quotes) -> generateReports htmlFile quotes
```



(note the use of Either here rather than the more usual Maybe.. This allows for a specific error to be returned rather than `Nothing`)

So, if the `decodeByName`  'works'   then call  `generateReports`, otherwise write an error message.

We read a `ByteString` (from `Data.ByteString.Lazy`, imported with the prefix `BL`) from the file and decode it with the `decodeByName` function from the `cassava` package’s `Data.Csv` module. This function has the following type signature:

```haskell
decodeByName :: FromNamedRecord a
             => BL.ByteString
             -> Either String (Header, Vector a)
```

The `quotes` value is later used as a value of the following type:

```haskell
(Functor t, Foldable t) => t QuoteData
```

The type checker figures out that the `a` type variable in the type signature for `decodeByName` refers to `QuoteData`. Remember, we’ve derived an instance of `FromNamedRecord` for it.

Type `Vector` comes from the `vector` package. This package provides an efficient implementation of `Int` indexed arrays with many optimizations for loop-like operations.

In the case of correct decoding, we get a `Vector` of `QuoteData` values. `Vector` implements both `Functor` and `Foldable` type classes. Thus, all our code for computing statistics and preparing reports remains intact (though it is quite performant thanks to `Vector` instances of `Functor` and `Foldable`). 

(This means that we don't need to worry about how `Vector` works etc. It's seamless for us)



Then the `generateReports` function does the rest of the job.

```haskell
generateReports :: (Functor t, Foldable t) =>
                 String ->  t QuoteData -> IO ()
generateReports htmlFl quotes = do
  putStr textRpt
  BL.writeFile htmlFl htmlRpt
 where
   statInfo' = statInfo quotes
   textRpt = textReport statInfo'
   htmlRpt = htmlReport  quotes statInfo' 
```



Once we have `Text` values of the html file name, we print the report to the console, then  we export the HTML report into the file with the given name. That is all for this project.

The full version of this code is available [here](./archives/stockquotes.zip).