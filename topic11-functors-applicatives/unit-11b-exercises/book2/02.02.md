# The Functor type class

We have  seen quite a few parameterized types (types that take another type as an argument). We have looked at types that represent containers, such as List and Map. We havealso seen parameterized types that represent a context, such as Maybe for error values and IO for values that come from the complex world of I/O. 

In this lesson, you’ll explore the powerful Functor type class. The Functor type class provides a generic interface for applying functions to values in a container or context. To get a sense of this, suppose you have the following types:

~~~
[Int]
Map String Int
Maybe Int
IO Int
~~~

These are four different types, but they’re all parameterized by the same type:
~~~ 
Int 
~~~

(Map is a special case, but the values are type Int). 

Now suppose you have a function with the following type signature:
~~~
Int -> String
~~~

# CONSIDER THIS
You have a potentially missing Int (a Maybe Int). You want to square this value, turn it into a string, and then add an ! to the end. The function that you want to pass this value to, printInt, assumes that there might be missing values already:
~~~
printInt :: Maybe String -> IO ()
printInt Nothing = putStrLn "value missing"
printInt (Just val) = putStrLn val
~~~

How can you transform your Maybe Int into a Maybe String to be used by printInt?

 It turns out you can do computation on a potentially missing value without having to worry about whether it’s actually missing.

Suppose you get a number from a csv file. There are plenty of reasons why a read would result in a null value. Here are two sample values of type Maybe Int:   failedRequest and successfulRequest.

~~~
successfulRequest :: Maybe Int
successfulRequest = Just 6

failedRequest :: Maybe Int
failedRequest = Nothing
~~~

Next imagine you need to increment the number you received from the database and then write it back to the database. You would  like to keep your value in a Maybe. Given what you know so far, you could write a special incMaybe function to handle this.

~~~
incMaybe :: Maybe Int -> Maybe Int
incMaybe (Just n) = Just (n + 1)
incMaybe Nothing = Nothing
~~~

This works fine 
~~~
GHCi> incMaybe successfulRequest
Just 7
GHCi> incMaybe failedRequest
Nothing
~~~
but scales horribly.

The increment function is just (+ 1), but in our example, you need to rewrite it for Maybe. This solution means that you’d have to rewrite a special version of every existing function you want to use in a Maybe! This greatly limits the usefulness of tools such as Maybe. Luckily, Haskell has a type class that solves this problem, called Functor.

Quick Exercise:
Q1. Write the function 
 ~~~
reverseMaybe :: Maybe String -> Maybe String 
~~~

that reverses a Maybe String and returns it as a Maybe String.

