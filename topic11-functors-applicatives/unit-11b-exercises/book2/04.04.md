# One interface for four problems

Members of Functor that you’ve seen so far include 
- List, 
- Map, (we haven't really spoken about Map but I am assuming that you are familiar with the idea. Let me know if you are not.)
- Maybe, and 
- IO. 
 
 
To demonstrate how Functor allows you to generalize by solving a single problem the same way in multiple parameterized types, you’ll explore how working with the same data type in multiple contexts can represent different problems. Then you’ll see how Functor’s <$> makes it easy to solve each of these problems in the same way. Rather than work with simple types such as Int or String, you’ll work with something more complicated: a RobotPart data type.


In this example, you’re going to assume that you’re in the business of manufacturing robot parts. Here’s the basic data type for your robot part.

~~~
data RobotPart = RobotPart
   { name :: String
   , description :: String
   , cost :: Double
   , count :: Int
   } deriving Show
~~~

Here are some example robot parts you’ll use in this section.

~~~
leftArm :: RobotPart
leftArm  = RobotPart
   { name = "left arm"
   , description = "left arm for face punching!"
   , cost = 1000.00
   , count = 3
   }

rightArm :: RobotPart
rightArm  = RobotPart
   { name = "right arm"
   , description = "right arm for kind hand gestures"
   , cost = 1025.00
   , count = 5
   }

robotHead :: RobotPart
robotHead  = RobotPart
   { name = "robot head"
   , description = "this head looks mad"
   , cost = 5092.25
   , count = 2
   }
~~~

One thing that we might need to do is to render the information contained in a RobotPart as HTML. Here’s code for rendering an individual RobotPart as an HTML snippet.

~~~
type Html = String

renderHtml :: RobotPart -> Html
renderHtml part = mconcat ["<h2>",partName, "</h2>"
                          ,"<p><h3>desc</h3>",partDesc
                          ,"</p><p><h3>cost</h3>"
                          ,partCost
                          ,"</p><p><h3>count</h3>"
                          ,partCount,"</p>"]
 where partName = name part
       partDesc = description part
       partCost = show (cost part)
       partCount = show (count part)
~~~

In many cases, you’ll want to convert a RobotPart into an HTML snippet. Next you’ll see four scenarios of this, using different parametrized types.

You’ll start by using the Map type to create partsDB, which is your internal database of RobotParts.

~~~
import qualified Data.Map as Map

partsDB :: Map.Map Int RobotPart
partsDB = Map.fromList keyVals
 where keys = [1,2,3]
       vals = [leftArm,rightArm,robotHead]
       keyVals = zip keys vals
~~~

`Map` is a useful type for this example because it naturally involves three instances of `Functor`: it’s made from a `List`, returns `Maybe` values, and is itself a `Functor`.

# Converting a Maybe RobotPart to Maybe Html
Now suppose you have a website driven by partsDB. It’s reasonable that you’d have a request containing an ID for a part that you wish to insert into a web page. Assume that an insertSnippet IO action will take HTML and insert it into a page’s template. It’s also reasonable to assume that many data models might be generating snippets. Because any one of these models may have an error, you’ll assume that insertSnippet accepts Maybe Html as its input, allowing the template engine to handle missing snippets as it sees fit. Here’s the type signature of your imaginary function:
~~~
insertSnippet :: Maybe Html -> IO ()
~~~
The problem you need to solve is looking up a part and passing that part as `Maybe Html` to `insertSnippet`. Here’s an example of fetching a `RobotPart` from your `partsDB`.
~~~
partVal :: Maybe RobotPart
partVal = Map.lookup 1 partsDB
~~~
Because `Maybe` is a `Functor`, you can use `<$>` to transform your `RobotPart` into `HTML` while remaining in a `Maybe`.

~~~
partHtml :: Maybe Html
partHtml = renderHtml <$> partVal
~~~
You can now pass `partHtml` to `insertSnippet` easily because of `Functor`.

# Converting a list of RobotParts to a list of HTML

Next suppose you want to create an index page of all your parts. You can get a list of parts from your partsDB like this.
~~~
allParts :: [RobotPart]
allParts = map snd (Map.toList partsDB)
~~~
`List` is also an instance of `Functor`. In fact, `fmap` for a `List` is the regular map function you’ve been using all during the module. Here’s how you can apply `renderHtml` to a list of values by using `<$>`.

~~~
allPartsHtml :: [Html]
allPartsHtml = renderHtml <$> allParts
~~~

Because `<$>` is just `fmap`, and for lists `fmap` is just `map`, this code is identical to the following:

~~~
allPartsHtml :: [Html]
allPartsHtml = map renderHtml allParts
~~~

For lists, it’s more common to use `map` over `<$>`, but it’s important to realize these are identical. One way to think of the `Functor` type class is as “things that can be mapped over".

Q3
Rewrite the definition of all parts to use `<$>` instead of `map`.

# Converting a Map of RobotParts to HTML
The `partsDB` `Map` has been useful, but it turns out all you need it for is converting `RobotParts` to `HTML`. If that’s the case, wouldn’t it make more sense to have an `htmlPartsDB` so you don’t have to continually convert? Because `Map` is an instance of `Functor`, you can do this easily:

~~~
htmlPartsDB :: Map.Map Int Html
htmlPartsDB = renderHtml <$> partsDB
~~~

Now you can see that you’ve transformed your `Map` of `RobotParts` into a `Map` of `Html` snippets!

~~~
GHCi> Map.lookup 1 htmlPartsDB
Just "<h2>left arm</h2><p><h3>desc</h3>left ...
~~~

This example highlights just how powerful the simple interface that `Functor` provides can be. You can now trivially perform any transformation that you can on a `RobotPart` to an entire `Map` of robot parts.

You may have noticed something strange about `Map` being a Functor.  If you look at the behavior of <$> on your partsDB, it becomes clear. `Functor` for `Map` is concerned only about the `Map`’s values and not its keys. When `Map` is made an instance of Functor, you’re concerned only about a single type variable, the one used for its values. So for the purposes of Map being a member of Functor, you treat it as having the type of its `values` or second field.

# Transforming an IO RobotPart into IO Html
Finally, you might have a `RobotPart` that comes from `IO`. You’ll simulate this by using return to create an `IO` type of a `RobotPart`.

~~~
leftArmIO :: IO RobotPart
leftArmIO = return leftArm
~~~

Suppose you want to turn this into `HTML` so that you can write the `HTML` snippet to a file. By now, the pattern should start to be familiar:

~~~
htmlSnippet :: IO Html
htmlSnippet = renderHtml <$> leftArmIO
~~~

Let’s take a look at all of these transformations at once:

~~~
partHtml :: Maybe Html
partHtml = renderHtml <$> partVal

allPartsHtml :: [Html]
allPartsHtml = renderHtml <$> allParts

htmlPartsDB :: Map.Map Int Html
htmlPartsDB = renderHtml <$> partsDB

htmlSnippet :: IO Html
htmlSnippet = renderHtml <$> leftArmIO
~~~

As you can see, `Functor`’s `<$>` provides a common interface to apply any function to a value in a context. For types such as `List` and `Map`, this is a convenient way to update values in these containers. For `IO`, it’s essential to be able to change values in an `IO` context, because you can’t take IO values out of their context.

Q4. 
Using a minimal type Box as an example:

~~~
data Box a = Box a deriving Show
~~~
Implement the `Functor` type class for `Box`. Then implement `morePresents`, which changes a box from type `Box` a to one of type `Box [a]`, which has n copies of the original value in the box in a list. Make sure to use `fmap` to implement this.

Q5.
Now suppose you have a simple box like this:

~~~
myBox :: Box Int
myBox = Box 1
~~~

Use `fmap` to put the value in your Box in another Box. Then define a function `unwrap` that takes a value out of a box, and use `fmap `on that function to get your original box. Here’s how your code should work in GHCi:

~~~
GHCi> wrapped = fmap ? myBox
GHCi> wrapped
Box (Box 1)
GHCi> fmap unwrap wrapped
Box 1
~~~

Q6
Write a command-line interface for `partsDB` that lets the user look up the cost of an item, given an `ID`. Use the `Maybe` type to handle the case of the user entering missing input.