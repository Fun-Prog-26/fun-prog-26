# Using functions in context with the Functor type class

Haskell has a wonderful solution to this problem. Maybe is a member of the Functor type class. The Functor type class requires only one definition: fmap:

![](./img/funct.jpeg)

We will use the `<$>` version which is the binary version of `fmap`

~~~
fmap f a    
~~~
is the same as 
~~~
f <$> a
~~~

Now, we can define fmap as a generalization of our custom incMaybe function.
~~~
instance Functor Maybe where
  fmap func (Just n) = Just (func n)
  fmap func Nothing = Nothing
~~~

With fmap, we no longer need a special function for keeping your value in a Maybe:
~~~
GHCi> fmap (+ 1) successfulRequest
Just 7
GHCi> fmap (+ 1) failedRequest
Nothing
~~~

Though `fmap` is the official function name, in practice the binary operator <$> is used much more frequently:

~~~
GHCi> (+ 1) <$> successfulRequest
Just 7
GHCi> (+ 1) <$> failedRequest
Nothing
~~~

In this example, (+ 1) adds 1 into the Maybe Int and returns a Maybe Int as well. But it’s important to realize that the type signature of the function in fmap is (a -> b), meaning that the Maybe returned doesn’t need to be parameterized by the same type. Here are two examples of going from a `Maybe Int` to a `Maybe String`. (remember `show` returns a String from an Int)
~~~
successStr :: Maybe String
successStr = show <$> successfulRequest

failStr :: Maybe String
failStr = show <$> failedRequest
~~~

This ability to transform the types of values inside a Maybe is the true power of the Functor type class.

Q2. 
Use `fmap` or `<$>` to reverse a `Maybe String`.
