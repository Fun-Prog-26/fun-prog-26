# Our own version of Maybe. 

 - We now write our own version of *Maybe*, *MyMaybe*. So we write everything from scratch (because Maybe is part of Prelude, a lot of the background work was done for us. We look at the structures.)


~~~
data MyMaybe a = MyNothing | MyJust a deriving Show


mapMay :: (a -> b) -> MyMaybe a -> MyMaybe b 
mapMay _ MyNothing = MyNothing
mapMay f (MyJust x)   = MyJust (f x) 

instance Functor MyMaybe where 
   -- fmap :: (a -> b) -> MyMaybe a -> MyMaybe b 
   fmap = mapMay


instance Applicative MyMaybe where
    pure                        = MyJust
    (MyJust f) <*> (MyJust x)   = MyJust (f x)
    _          <*> _            = MyNothing

~~~

## Notes
  - We firstly introduce MyMaybe as a new *data* with two *constructors*
  - We then need to define what fmap means over this new *effect*. We call it *mapMay*. 
  - We use this mapMay in the *instance Functor* code.
  - We then use the *instance Applicative* to define what *pure* and <*> mean


If we now look at two functions using this MyMaybe

~~~
safeHead :: [a] -> MyMaybe a
safeHead []   = MyNothing
safeHead xs   = MyJust (head xs)

safeLast :: [a] -> MyMaybe a
safeLast []   = MyNothing
safeLast xs   = MyJust (last xs)
~~~

Show how you would use *safeHead* and *safeLast* to apply safeHead across a list of strings , e.g ["First String", "Second String"] (shoud get back [MyJust 'F', MyJust 'S']) using

  - *fmap*
  - <$>

##Applicative Functors - use of <*> 

Given *safeHead* and *safeLast* above (both of the same type) we can map a list of functions (using list effect) accross a list of lists 

~~~

ghci > [safeHead, safeLast] <*> ["First String1", "Second String2"]       -- will return 

ghci > [MyJust 'F',MyJust 'S',MyJust '1',MyJust '2']
-- and 
ghci > [safeHead, safeLast] <*>  ["First String1", "Second String2", ""]   -- will return
ghci > [MyJust 'F',MyJust 'S',MyNothing,MyJust '1',MyJust '2',MyNothing]
~~~

#Exercise
Given the following function : 

~~~

fromMaybe :: MyMaybe Char -> Char 
fromMaybe MyNothing = '-'
fromMaybe (MyJust ch ) = ch

~~~

which removes the Maybe part and replaces Nothing (MyNothing in this example) with '-'

show how you would use *fromMaybe* to return, instead (above example) of 


~~~

ghci > [MyJust 'F',MyJust 'S',MyNothing,MyJust '1',MyJust '2',MyNothing]

ghci > "FS-12-"   -- remember that this is equal to ['F', 'S', '-', '1', '2', '-']

~~~