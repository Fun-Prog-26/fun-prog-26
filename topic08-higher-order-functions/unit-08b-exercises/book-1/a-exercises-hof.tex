\documentclass{article}

\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[printsolution=true]{exercises}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}


\lstset{frame=tb,
  language=Haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
  }
%% Change this for title information 
\newcommand\ExTitle{Higher-order functions}

\newcommand\fullExTitle{Exercises \\ \ExTitle }
\newcommand\footerExTitle{\ExTitle -\  Exercises }

\pagestyle{fancy}
\fancyhead{} % clear all header fields
\renewcommand{\headrulewidth}{0pt} % no line in header area
\fancyfoot{} % clear all footer fields
\fancyfoot[LE,RO]{\thepage}           % page number in "outer" position of footer line
\fancyfoot[RE,LO]{\footerExTitle} % other info in "inner" position of footer line

%\usepackage[mathrm,colour,cntbysection]{czt}

\begin{document}
\begin{Huge}
	\begin{center}
	\fullExTitle
	\end{center}
 \end{Huge}
 When writing the following functions, you should try to eliminate as many unecessary arguments as possible.

\begin{exercise}

Show how the list comprehension \\
\begin{lstlisting}
  [f x | x <- xs, p x] 
\end{lstlisting}
can be re-expressed using the higher-order functions \textbf{\textit{map}} and \textbf{\textit{filter}}.
\end{exercise}

\begin{solution}
\begin{lstlisting}
  map f (filter p xs) 
\end{lstlisting}
\end{solution}

\begin{exercise} 
Without looking at the definitions from the standard Prelude, define the following higher-order library functions on lists. To use the \textbf{\textit{Prelude}} name, use 
\begin{lstlisting}[language=Haskell]
  import Prelude hiding (all, any, takeWhile, dropWhile)
\end{lstlisting}

\begin{enumerate}
	\item Decide if all elements of a list satisfy a predicate:
\begin{lstlisting}[language=Haskell]
all :: (a -> Bool) -> [a] -> Bool
\end{lstlisting}
	\item Decide if all elements of a list satisfy a predicate:
\begin{lstlisting}[language=Haskell]
any :: (a -> Bool) -> [a] -> Bool
\end{lstlisting}
	\item Select elements from a list while they satisfy a predicate:
\begin{lstlisting}[language=Haskell]
  takeWhile' :: (a -> Bool) -> [a] -> [a]
\end{lstlisting}
	\item Remove elements from a list while they satisfy a predicate
\begin{lstlisting}[language=Haskell]
dropWhile :: (a -> Bool) -> [a] -> [a]
\end{lstlisting}
\end{enumerate}
\end{exercise}

\begin{solution}
  \textbf{Note:} We use \textit{all'} etc so as not to clash with Prelude defined functions. 
  \begin{enumerate}
    \item Decide if all elements of a list satisfy a predicate:
  \begin{lstlisting}
  all' :: (a -> Bool) -> [a] -> Bool
  all' p = and . map p 
  \end{lstlisting}
    \item Decide if all elements of a list satisfy a predicate:
  \begin{lstlisting}
  any' :: (a -> Bool) -> [a] -> Bool
  any' p = or . map p
  \end{lstlisting}
    \item Select elements from a list while they satisfy a predicate:
  \begin{lstlisting}
    takeWhile' :: (a -> Bool) -> [a] -> [a]
    takeWhile' _ []                   = []
    takeWhile' p (x:xs)   |  p x       = x : takeWhile' p xs
                          | otherwise  = []
    \end{lstlisting}
    \item Remove elements from a list while they satisfy a predicate
  \begin{lstlisting}
    dropWhile' :: (a -> Bool) -> [a] -> [a]
    dropWhile' _ []                  = []
    dropWhile' p (x:xs) |  p x       = dropWhile' p xs
                        | otherwise  = x:xs
  \end{lstlisting}
  \end{enumerate}
\end{solution}

\pagebreak
\begin{exercise} 
Redefine the functions 
\begin{lstlisting}[language=Haskell]
map f
\end{lstlisting}
and
\begin{lstlisting}
filter p
\end{lstlisting}
using
\begin{lstlisting}[language=Haskell]
foldr
\end{lstlisting}

\end{exercise} 

\begin{solution}
  \begin{lstlisting}
  map f = foldr (\x xs -> f x : xs) []
\end{lstlisting}
\begin{lstlisting}
filter :: (a -> Bool) -> [a] -> [a]
filter p = foldr (\x acc -> if p x then x : acc else acc) []
\end{lstlisting}

\end{solution}

\begin{exercise}
Noting that $String$ is the same as $\lbrack Char \rbrack$. Define a function \textit{capitalises}, of type
\begin{lstlisting}[language=Haskell]

capitalises :: String -> String
\end{lstlisting}
which takes a list of characters as its argument and returns the
same list as its value except that each lower-case letter has been replaced by its
upper-case equivalent. Thus, \\ \textit{capitalises} "Bohemian Rhapsody" = "BOHEMIAN RHAPSODY". \\
\textbf{\textit{Hint:}} Use $toupper$ which returns the uppercase of a letter and  $map$. You should try to eliminate arguments where possible. 
\end{exercise} 

\begin{solution}
\begin{lstlisting}[language=Haskell]
capitalises :: String -> String
capitalises = map toUpper
\end{lstlisting} 
\end{solution}
\pagebreak
\begin{exercise} 
Define a function $squareall :: \lbrack Int \rbrack  \rightarrow  \lbrack Int \rbrack $ which takes a list of integers and
produces a list of the squares of those integers. For example, \\
$squareall \lbrack 6, 1, (-3) \rbrack = \lbrack 36, 1, 9 \rbrack $. \\
\textbf{\textit{Hint:}} Using map, You should try to eliminate arguments where possible. 

\end{exercise} 

\begin{solution}
\begin{lstlisting}[language=Haskell]
squareall :: [Int] -> [Int]
squareall = map (\x -> x*x)
\end{lstlisting}
\end{solution}


\begin{exercise} 
Define a function $nestedreverse$ which takes a list of strings as its argument
and reverses each element of the list and then reverses the resulting list. Thus, \\
$nestedreverse \ \lbrack$ "in", "the", "end"$ \rbrack = \lbrack$ "dne", "eht", "ni" $\rbrack$.

\textbf{\textit{Hint:}} Using map, you should try to eliminate arguments where possible. 

\end{exercise} 

\begin{solution}
\begin{lstlisting}[language=Haskell]
nestedreverse :: [String] -> [String]
nestedreverse = reverse . map reverse
\end{lstlisting}
\end{solution}


\begin{exercise} 
Define a function $atfront :: a \rightarrow \lbrack \lbrack  a \rbrack \rbrack \rightarrow  \lbrack \lbrack  a \rbrack \rbrack$  which takes an object and a list of lists and prepends  the object at the front of every component list. For example, \\
$atfront \ 7 \ \lbrack \lbrack 1,2 \rbrack , \lbrack \rbrack , \lbrack 3\rbrack \rbrack = \lbrack \lbrack 7,1,2 \rbrack, \lbrack 7 \rbrack, \lbrack7,3\rbrack \rbrack$. \\
\textbf{\textit{Hint:}} Using map, you should try to eliminate arguments where possible. 
\end{exercise} 


\begin{solution}
\begin{lstlisting}[language=Haskell]
atfront :: a -> [[a]] -> [[a]]
atfront x = map (x:) 
\end{lstlisting}
\end{solution}
\pagebreak

\begin{exercise} 
Define a function lengths which takes a list of strings as its argument and returns the list of their lengths. For example, \\
$lengths \  \lbrack$ "the", "end", "is","nigh"$ \rbrack \ = \ \lbrack $3, 3, 2, 4$\rbrack$. \\
\textbf{\textit{Hint:}} You should try to eliminate arguments where possible. 
\end{exercise} 

\begin{solution}
\begin{lstlisting}[language=Haskell]
lengths :: [String] -> [Int]
lengths = map length
\end{lstlisting}
\end{solution}

\begin{exercise}

Using the higher-order function map define a function $sumsq$ which takes an
integer $n$ as its argument and returns the sum of the squares of the first $n$
integers. That is to say,
$sumsq \ n = 1^{2} + 2^{2} + 3^{2} + \ldots + n^{2}$
\end{exercise} 

\begin{solution}
\begin{lstlisting}[language=Haskell]
square :: Num a => a -> a
square x = x * x
sumsq :: Integral a => a -> a
sumsq n = sum (map square [1..n])
\end{lstlisting}
\end{solution}

\begin{exercise} 
The function filter can be defined in terms of $concat$ and $map$:
\begin{lstlisting}[language=Haskell]
filter p = concat.map box where box x = ...
\end{lstlisting}
Write down the definition of box x   
\end{exercise} 

\begin{solution}
\begin{lstlisting}[language=Haskell]
filter1 :: (a -> Bool) -> [a] -> [a]
filter1 p = concat.map box
where box x
           | p x = [x]
           | otherwise = []
\end{lstlisting}
\end{solution}
\pagebreak
\begin{exercise} 
Define a function $wvowel$ (without vowels) which removes every occurrence of a
vowel from a list of characters.
\end{exercise} 

\begin{solution}
\begin{lstlisting}[language=Haskell]
wvowel :: String -> String
wvowel xs = filter f xs where f x = not (x == `a` ||
                                         x == `e` ||
                                         x == `i` ||
                                         x == `o` ||
                                         x == `u` )
\end{lstlisting}
\end{solution}

\begin{exercise} 
 Define a function wiv (without internal vowels) which takes a list of strings as its
argument and removes every occurrence of a vowel from each element. For example, 
\begin{lstlisting}[language=Haskell]
wiv ["the", "end", "is", "nigh"] = ["th", "nd", "s", "ngh"] 
\end{lstlisting}
\end{exercise} 

\begin{solution}
\begin{lstlisting}[language=Haskell]
wiv :: [String] -> [String]
wiv = map wvowel
\end{lstlisting}
\end{solution}


\end{document}